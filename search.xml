<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>tcp</title>
      <link href="/2020/05/06/tcp/"/>
      <url>/2020/05/06/tcp/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP简介"><a href="#TCP简介" class="headerlink" title="TCP简介"></a>TCP简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>既然要讲三次握手，就要好好讲。那么为了讲的细一点，就从TCP开始讲起把。<br>首先我们先解决是什么的问题。<br>TCP（Transmission Control Protocol）<strong>是一种面向连接的、可靠的、基于字节流的传输层通信协议</strong>，由IETF的RFC 793定义。<br>既然它是面向连接的、可靠的。那么什么是不可靠的呢。没错，它就是UDP，它是面向报文的。这里就不详细展开。</p><h2 id="TCP报文结构"><a href="#TCP报文结构" class="headerlink" title="TCP报文结构"></a>TCP报文结构</h2><p><img src="image-816fcc9a08d74868813cbe88c7315d9b.png" alt="image.png"></p><p>从上到下来看、<strong>目标端口</strong>以及<strong>源端口</strong>这个很好理解，就是发送和接收的两个端口</p><blockquote><p>这里先附一些参考链接<br>基础：<br><a href="https://www.jianshu.com/p/ca64764e4a26" target="_blank" rel="noopener">https://www.jianshu.com/p/ca64764e4a26</a><br><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C</a><br><a href="https://github.com/wolverinn/Waking-Up/blob/master/" target="_blank" rel="noopener">https://github.com/wolverinn/Waking-Up/blob/master/</a><br>深入：<br><a href="https://mp.weixin.qq.com/s/S1mv8AE_pQz3uHjRGS7tWg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/S1mv8AE_pQz3uHjRGS7tWg</a><br><a href="https://www.jianshu.com/p/15754b4e9458" target="_blank" rel="noopener">https://www.jianshu.com/p/15754b4e9458</a></p></blockquote><h3 id="序号（seq）"><a href="#序号（seq）" class="headerlink" title="序号（seq）"></a>序号（seq）</h3><p>这个是标志当前数据流的开始位置在总数据流上的标号，这样说可能比较抽象，我给大家举个例子。<br>比如说我有10000个字节的数据要发送，然后他被切分成20段的TCP报文，那么第一段的就是isn（初始序列号），第二段就是isn+500，第三段就是isn+1000。<br>那么这样有什么好处呢，这样数据的接收端就可以判断有没有数据在传输的过程中丢失了，从而给出<strong>应答</strong>，也为重传提供了基础。<br>然后再说说isn，他是随机生成的，可以一定程度上避免别人重置你的链接，提升可靠性，为什么呢这里不多说，可以去翻上面的参考链接</p><h3 id="确认号（ack）"><a href="#确认号（ack）" class="headerlink" title="确认号（ack）"></a>确认号（ack）</h3><p>其实这个就是应答的编号。如果接收端接收到了相应的seq，并且在此seq之前的数据全部接收到了，那么他就会发送一次ACK=1（这个是标志位），ack=seq+1的包（或者叫消息）到发送端，表示数据以及在此之前的数据都接受到了，那么下次发送端发送的就从这个ack的值开始吧，即下次的seq=ack。</p><p><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度<br><strong>同步 SYN</strong>：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。<br><strong>终止 FIN</strong>：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。<br><strong>确认 ACK</strong> :只有他置1的时候ack才会有效，其实就是表示他算是一个应答，所以其实除了建立连接的第一个报文，其他都是会带ACK的。而与之相对的，SYN通常也只在前两次握手中出现。FIN只在挥手的时候出现。<br><strong>窗口</strong>：由于接收方的窗口可能动态调整，所以这个区域是留给接收方告诉发送方自身的窗口变化的，至于窗口是什么之后会在介绍，也可以看上面的参考链接了解。</p><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>终于可以介绍握手了，上了上面的基础，我们来说握手就很简单<br><img src="http://111.230.171.202:8090/upload/2020/2/image-df0c523fbcad4fa6ac2f387b528a269b.png" alt="image.png"><br>我们分步解析<br>大家可以看到，在<strong>第一次握手</strong>中，发送方（客户端）将SYN置1，这是建立连接的姿势，然后获取一个随机的isn值，我们称之为client_isn，然后将其作为seq，再把整个报文发给服务端。<br>客户端接收到了这个值之后，他也会产生一个sever_isn，但是这个却不是完全随机产生的，该序列号是用SYN报文段的源和目的IP地址与端口号以及仅有该服务器知道的秘钥生成的散列函数值,这是为了抵御SYN泛洪攻击，暂不详谈。<br>那么根据我们已经学习到的知识，在我们服务器产生的报文中，ack=client_isn+0+1（没有实际数据），然后seq = sever_isn。然后服务端再把它发送到客户端，这就是<strong>第二次握手</strong>。<br>最后是<strong>第三次握手</strong>，这次是客户端发送给服务端，seq 就是服务端的ack，ack就是服务端的seq+1，至此连接建立。 </p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="为什么是三次而不是两次握手呢"><a href="#为什么是三次而不是两次握手呢" class="headerlink" title="为什么是三次而不是两次握手呢"></a>为什么是三次而不是两次握手呢</h3><p>假设一种情况</p><blockquote><p>client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。</p></blockquote><p>而如果发生了这种情况，sever端会正常的返回ack包，但是client端会检测到异常并将rst=1来重置连接。</p><h3 id="当第三次ACK丢失了，怎么办"><a href="#当第三次ACK丢失了，怎么办" class="headerlink" title="当第三次ACK丢失了，怎么办"></a>当第三次ACK丢失了，怎么办</h3><p>在上面的ack与seq的关系中，我们知道，在没有接收到sever端的新的包的情况下，我们client端的seq和ack的值是不会变的。那么，第三次ack丢失，但其实对于client来说，他已经认为连接成功了，那么他将会开始发送数据包，而数据包因为seq和ack都和本来第三次的ack一样，所以也就相当于第三次握手成功了。<br>有些博文认为连接是会被重置的，关于这一点，大家可以看看这一篇</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTU2NzQwMQ==&mid=2247483822&idx=1&sn=36e7c4fa0a995b3119f4c7c9520f56d0&chksm=fc778268cb000b7e3a40b030809eb1357bfbdb10a4268150961e96848d7cc5359a459ceb342a&scene=126&sessionid=0&clicktime=1578640584&ascene=3&devicetype=iOS13.1.2&version=1700092d&nettype=3G+&abtest_cookie=AQABAAgAAQCehh4AAAA%3D&lang=zh_CN&fontScale=100&exportkey=A9XwKpXoXsjogxWa3FGR89g%3D&pass_ticket=Fxckyb2nvsgXWI65rTmpxZgrPtfrvpVwbJ3CfU19%2FQadLPcAQY9ovxpq%2B9QK7jro&wx_header=1" target="_blank" rel="noopener">【面试必会】全网最具深度的三次握手、四次挥手讲解</a></p><h3 id="如果已经建立了连接，但客户端出现了故障怎么办？"><a href="#如果已经建立了连接，但客户端出现了故障怎么办？" class="headerlink" title="如果已经建立了连接，但客户端出现了故障怎么办？"></a>如果已经建立了连接，但客户端出现了故障怎么办？</h3><blockquote><p>服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接</p></blockquote><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><h2 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h2><p><img src="http://111.230.171.202:8090/upload/2020/2/image-cb1b05696bd64259b4a818a66ae6a6a3.png" alt="image.png"><br>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；表示自己要中断连接，进入FIN_WAIT_1状态；<br>第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。这个阶段主要是给服务端将剩余数据发给客户端的。<br>第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；<br>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</p><h2 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="为何不将第三次挥手和第二次结合？"><a href="#为何不将第三次挥手和第二次结合？" class="headerlink" title="为何不将第三次挥手和第二次结合？"></a>为何不将第三次挥手和第二次结合？</h3><p>在之前已经提到过，因为服务端有可能还有数据没有传完，所以要分开。而ACK的意义是让客户端知晓服务端已收到请求，这也是为什么挥手比握手要多出一步的原因。</p><h3 id="如果第二次挥手中，客户端没有收到怎么办？"><a href="#如果第二次挥手中，客户端没有收到怎么办？" class="headerlink" title="如果第二次挥手中，客户端没有收到怎么办？"></a>如果第二次挥手中，客户端没有收到怎么办？</h3><p>由于没有收到，客户端会重新发送FIN。</p><h3 id="最后的TIME-WAIT有什么意义？"><a href="#最后的TIME-WAIT有什么意义？" class="headerlink" title="最后的TIME_WAIT有什么意义？"></a>最后的TIME_WAIT有什么意义？</h3><p>确保最后客户端的ACK，服务端已经接收到了（如果没接收到，服务端会重发）。</p>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/05/hello-world/"/>
      <url>/2020/05/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
